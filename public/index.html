<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AOI Labeler v3</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; background: #0b1020; color: #e6eaf2; }
    .wrap { display: grid; grid-template-columns: 380px 1fr; height: 100vh; }
    .panel { padding: 14px; border-right: 1px solid #24304d; overflow: auto; }
    input, button { width: 100%; padding: 8px; margin-top: 6px; border-radius: 8px; border: 1px solid #314268; background:#121a2f; color:#e6eaf2; }
    button { cursor: pointer; }
    .canvas-wrap { overflow: auto; background: #090d1a; }
    canvas { display:block; margin: 0 auto; background:#111; }
    .hint { font-size:12px; opacity:.88; line-height:1.45; margin-top:10px; }
    .item { background:#121a2f; border:1px solid #2c3d64; border-radius:8px; padding:8px; margin:6px 0; font-size:13px; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h2>AOI Labeler v3</h2>

    <div class="item"><b>步骤1（必选）</b><br/>上传场景底图（jpg/png）</div>
    <input id="imgInput" type="file" accept="image/*" />

    <div class="item"><b>步骤2（可选）</b><br/>上传眼动点 CSV（含列：<code>Gaze Point X[px]</code>、<code>Gaze Point Y[px]</code>）</div>
    <input id="csvInput" type="file" accept=".csv,text/csv" />
    <div id="csvStatus" style="font-size:12px;color:#7dffb3"></div>

    <input id="className" placeholder="AOI类名，如 pingpong_table" />
    <button id="startPolyBtn">开始绘制</button>
    <button id="closePolyBtn">闭合并保存（或点击首点自动闭合）</button>
    <button id="undoPointBtn">撤销当前点</button>
    <button id="clearCurrentBtn">清空当前绘制</button>

    <hr/>
    <button id="deleteSelectedBtn">删除选中 polygon</button>
    <button id="insertVertexBtn">在最近边插入顶点</button>
    <button id="deleteVertexBtn">删除最近顶点</button>

    <input id="renameOld" placeholder="旧类名" />
    <input id="renameNew" placeholder="新类名" />
    <button id="renameBtn">重命名类</button>

    <input id="aoiImport" type="file" accept="application/json,.json" />
    <button id="exportBtn">导出 aoi.json</button>
    <button id="toggleGazeBtn">开关 gaze 点</button>

    <hr/>
    <h3 style="margin:8px 0 4px;">批处理（1 张底图 + 多个 CSV）</h3>
    <input id="batchCsvInput" type="file" accept=".csv,text/csv" multiple />
    <button id="runBatchBtn">批量计算 AOI 指标</button>
    <button id="downloadBatchZipBtn">下载 batch_results.zip</button>
    <div id="batchStatus" style="font-size:12px;color:#7dffb3;line-height:1.5;margin-top:6px;"></div>

    <div class="hint">
      交互（v3）：<br/>
      - 滚轮缩放，空白处拖动画布平移<br/>
      - 点击 polygon 选中；拖顶点可编辑<br/>
      - 按住 Shift 拖动选中 polygon 可整体移动<br/>
      - 绘制时点击首点附近自动闭合
    </div>
    <div id="summary"></div>
  </div>
  <div class="canvas-wrap"><canvas id="canvas"></canvas></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const summary = document.getElementById('summary');
const csvStatus = document.getElementById('csvStatus');
const batchStatus = document.getElementById('batchStatus');
canvas.width = 1400;
canvas.height = 900;
drawEmptyState();

let image = new Image(), imageLoaded=false;
let drawing=false, currentClass='', currentPoly=[];
let aois={}; // class -> [{points:[[x,y],...]}]
let gazePoints=[], showGaze=true;
let batchCsvFiles=[];
let batchZipBlob=null;
let selected=null; // {className, polyIndex}
let dragVertex=null; // {className, polyIndex, vertexIndex}
let dragPoly=null; // {className, polyIndex, lastX,lastY}
let panMode=false, panStart=null;
let hoverCanvasPoint=null;

const view = { scale:1, tx:0, ty:0 };

function drawEmptyState(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#0b1328';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='rgba(255,255,255,0.85)';
  ctx.font='20px Arial';
  ctx.fillText('请先上传场景底图（必选）', 40, 60);
  ctx.font='14px Arial';
  ctx.fillStyle='rgba(255,255,255,0.65)';
  ctx.fillText('可选：再上传眼动 CSV 叠加 gaze 点。', 40, 90);
}


function colorForClass(name){ let h=0; for(let i=0;i<name.length;i++) h=(h*31+name.charCodeAt(i))%360; return `hsl(${h},80%,60%)`; }
function centroid(poly){ let x=0,y=0; poly.forEach(p=>{x+=p[0];y+=p[1]}); return [x/poly.length,y/poly.length]; }
function worldToScreen(x,y){ return [x*view.scale+view.tx, y*view.scale+view.ty]; }
function screenToWorld(x,y){ return [(x-view.tx)/view.scale, (y-view.ty)/view.scale]; }

function pointInPoly(px, py, poly){
  let inside=false;
  for(let i=0,j=poly.length-1;i<poly.length;j=i++){
    const xi=poly[i][0], yi=poly[i][1], xj=poly[j][0], yj=poly[j][1];
    const intersect=((yi>py)!==(yj>py)) && (px < (xj-xi)*(py-yi)/((yj-yi)||1e-9)+xi);
    if(intersect) inside=!inside;
  }
  return inside;
}

function nearestVertex(wx,wy,thPx=10){
  const th = thPx/view.scale;
  let best=null;
  for(const [cls, polys] of Object.entries(aois)){
    polys.forEach((pObj,pi)=>pObj.points.forEach((pt,vi)=>{
      const d=Math.hypot(pt[0]-wx, pt[1]-wy);
      if(d<=th && (!best || d<best.d)) best={className:cls, polyIndex:pi, vertexIndex:vi, d};
    }));
  }
  return best;
}

function selectPolygonAt(wx,wy){
  for(const [cls, polys] of Object.entries(aois)) for(let i=0;i<polys.length;i++) if(pointInPoly(wx,wy,polys[i].points)) return {className:cls, polyIndex:i};
  return null;
}

function distPointToSeg(px,py,x1,y1,x2,y2){
  const A=px-x1, B=py-y1, C=x2-x1, D=y2-y1;
  const dot=A*C+B*D, len=C*C+D*D;
  let t = len ? dot/len : 0; t=Math.max(0,Math.min(1,t));
  const x=x1+t*C, y=y1+t*D;
  return {d:Math.hypot(px-x,py-y), x,y,t};
}

function nearestEdge(poly, wx, wy){
  let best=null;
  for(let i=0;i<poly.length;i++){
    const a=poly[i], b=poly[(i+1)%poly.length];
    const r=distPointToSeg(wx,wy,a[0],a[1],b[0],b[1]);
    if(!best || r.d<best.d) best={edgeStart:i, ...r};
  }
  return best;
}

function redraw(){
  if(!imageLoaded){ drawEmptyState(); return; }
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
  ctx.drawImage(image,0,0);

  if(showGaze && gazePoints.length){
    ctx.fillStyle='rgba(255,255,255,0.35)';
    for(const p of gazePoints) ctx.fillRect(p[0],p[1],1,1);
  }

  for(const [cls, polys] of Object.entries(aois)){
    const color=colorForClass(cls);
    polys.forEach((pObj,idx)=>{
      const poly=pObj.points; if(poly.length<2) return;
      const isSel=selected && selected.className===cls && selected.polyIndex===idx;
      ctx.strokeStyle=isSel?'#ffd166':color;
      ctx.fillStyle=isSel?'#ffd166':color;
      ctx.lineWidth=(isSel?3:2)/view.scale;
      ctx.beginPath(); ctx.moveTo(poly[0][0],poly[0][1]); for(let i=1;i<poly.length;i++) ctx.lineTo(poly[i][0],poly[i][1]); ctx.closePath();
      ctx.globalAlpha=.2; ctx.fill(); ctx.globalAlpha=1; ctx.stroke();
      for(const p of poly){ ctx.beginPath(); ctx.arc(p[0],p[1],3/view.scale,0,Math.PI*2); ctx.fill(); }
      const c=centroid(poly); ctx.fillStyle='#fff'; ctx.font=`${12/view.scale}px Arial`; ctx.fillText(`${cls}#${idx+1}`,c[0],c[1]);
    });
  }

  if(currentPoly.length){
    ctx.strokeStyle='#00e5ff'; ctx.fillStyle='#00e5ff'; ctx.lineWidth=2/view.scale;
    ctx.beginPath(); ctx.moveTo(currentPoly[0][0],currentPoly[0][1]); for(let i=1;i<currentPoly.length;i++) ctx.lineTo(currentPoly[i][0],currentPoly[i][1]);
    if(hoverCanvasPoint){ ctx.lineTo(hoverCanvasPoint[0],hoverCanvasPoint[1]); }
    ctx.stroke();
    currentPoly.forEach(p=>{ctx.beginPath(); ctx.arc(p[0],p[1],3/view.scale,0,Math.PI*2); ctx.fill();});
  }
}


function parseCSVRows(text){
  const out = Papa.parse(text, {header:true, skipEmptyLines:true});
  if(out.errors && out.errors.length){
    // keep going; Papa can still parse partial rows
  }
  return out.data || [];
}

function pointInPolySimple(px, py, poly){
  let inside=false;
  for(let i=0,j=poly.length-1;i<poly.length;j=i++){
    const xi=poly[i][0], yi=poly[i][1], xj=poly[j][0], yj=poly[j][1];
    const intersect=((yi>py)!==(yj>py)) && (px < (xj-xi)*(py-yi)/((yj-yi)||1e-12)+xi);
    if(intersect) inside=!inside;
  }
  return inside;
}

function toNum(v){
  const n = Number(v);
  return Number.isFinite(n) ? n : NaN;
}

function computeAoiMetricsFromRows(rows, aoisObj){
  const classes = Object.keys(aoisObj||{});
  const tvals = rows.map(r=>toNum(r['Recording Time Stamp[ms]'])).filter(Number.isFinite);
  const t0 = tvals.length ? Math.min(...tvals) : NaN;

  const perPolygon=[];
  const classSamples = {}; // cls -> rows in union (approx by row index dedup)

  classes.forEach(cls=>{
    const polys = (aoisObj[cls]||[]).map(p=>p.points||p);
    const unionHit = new Set();

    polys.forEach((poly, idx)=>{
      let samples=0;
      let dwell=0;
      const fixSet=new Set();
      let minT=Infinity;

      rows.forEach((r, ri)=>{
        const x=toNum(r['Gaze Point X[px]']);
        const y=toNum(r['Gaze Point Y[px]']);
        if(!Number.isFinite(x)||!Number.isFinite(y)) return;
        if(pointInPolySimple(x,y,poly)){
          samples += 1;
          unionHit.add(ri);
          const fd=toNum(r['Fixation Duration[ms]']);
          if(Number.isFinite(fd)) dwell += fd;
          const fx=r['Fixation Index'];
          if(fx!==undefined && fx!==null && String(fx).trim()!=='') fixSet.add(String(fx));
          const t=toNum(r['Recording Time Stamp[ms]']);
          if(Number.isFinite(t) && t<minT) minT=t;
        }
      });

      perPolygon.push({
        class_name: cls,
        polygon_id: idx+1,
        samples,
        dwell_time_ms: dwell,
        fixation_count: fixSet.size,
        TTFF_ms: Number.isFinite(minT) && Number.isFinite(t0) ? (minT - t0) : ''
      });
    });

    classSamples[cls] = unionHit;
  });

  const perClass=[];
  classes.forEach(cls=>{
    const hitIdx = classSamples[cls] || new Set();
    let dwell=0;
    const fixSet=new Set();
    let minT=Infinity;

    for(const ri of hitIdx){
      const r=rows[ri];
      const fd=toNum(r['Fixation Duration[ms]']);
      if(Number.isFinite(fd)) dwell += fd;
      const fx=r['Fixation Index'];
      if(fx!==undefined && fx!==null && String(fx).trim()!=='') fixSet.add(String(fx));
      const t=toNum(r['Recording Time Stamp[ms]']);
      if(Number.isFinite(t) && t<minT) minT=t;
    }

    perClass.push({
      class_name: cls,
      polygon_count: (aoisObj[cls]||[]).length,
      samples: hitIdx.size,
      dwell_time_ms: dwell,
      fixation_count: fixSet.size,
      TTFF_ms: Number.isFinite(minT) && Number.isFinite(t0) ? (minT - t0) : ''
    });
  });

  return {perPolygon, perClass};
}

function rowsToCSV(rows, columns){
  const esc = (v)=>{
    if(v===null||v===undefined) return '';
    const sv=String(v);
    return /[",\n]/.test(sv) ? '"'+sv.replace(/"/g,'""')+'"' : sv;
  };
  const header = columns.join(',');
  const body = rows.map(r=>columns.map(c=>esc(r[c])).join(','));
  return [header, ...body].join('\n');
}

async function runBatch(){
  if(!Object.keys(aois).length) return alert('请先完成 AOI 框选或导入 aoi.json');
  if(!batchCsvFiles.length) return alert('请先选择多个 CSV 文件');

  const allClassRows=[];
  const zip = new JSZip();
  const failed=[];

  for(let i=0;i<batchCsvFiles.length;i++){
    const f=batchCsvFiles[i];
    batchStatus.textContent = `处理中 ${i+1}/${batchCsvFiles.length}: ${f.name}`;
    try{
      const text = await f.text();
      const rows = parseCSVRows(text);
      if(!rows.length) throw new Error('空CSV或解析失败');
      const hasX = 'Gaze Point X[px]' in rows[0];
      const hasY = 'Gaze Point Y[px]' in rows[0];
      if(!hasX || !hasY) throw new Error('缺少 Gaze Point X[px]/Y[px] 列');

      const {perPolygon, perClass} = computeAoiMetricsFromRows(rows, aois);
      const base = f.name.replace(/\.csv$/i, '');

      const classCols = ['class_name','polygon_count','samples','dwell_time_ms','fixation_count','TTFF_ms'];
      const polyCols = ['class_name','polygon_id','samples','dwell_time_ms','fixation_count','TTFF_ms'];

      zip.file(`per_file/${base}_aoi_metrics_by_class.csv`, rowsToCSV(perClass, classCols));
      zip.file(`per_file/${base}_aoi_metrics_by_polygon.csv`, rowsToCSV(perPolygon, polyCols));

      perClass.forEach(r=>allClassRows.push({...r, source_file:f.name}));
    }catch(err){
      failed.push({file:f.name, error:String(err.message||err)});
    }
  }

  const summaryCols = ['source_file','class_name','polygon_count','samples','dwell_time_ms','fixation_count','TTFF_ms'];
  zip.file('summary_by_class.csv', rowsToCSV(allClassRows, summaryCols));

  if(failed.length){
    zip.file('failed_files.csv', rowsToCSV(failed, ['file','error']));
  }

  batchZipBlob = await zip.generateAsync({type:'blob'});
  batchStatus.textContent = `完成：成功 ${batchCsvFiles.length - failed.length}，失败 ${failed.length}。点击“下载 batch_results.zip”。`;
}

function refreshSummary(){
  let html='<h3>AOI 概览</h3>';
  const names=Object.keys(aois); if(!names.length) html+='<div class="item">暂无 AOI</div>';
  for(const n of names) html+=`<div class="item"><b>${n}</b> · ${aois[n].length} polygons</div>`;
  summary.innerHTML=html;
}

function canvasPos(e){ const r=canvas.getBoundingClientRect(); return [e.clientX-r.left, e.clientY-r.top]; }

document.getElementById('imgInput').addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  image=new Image(); image.onload=()=>{ imageLoaded=true; canvas.width=Math.max(1200,image.width); canvas.height=Math.max(800,image.height); view.scale=1; view.tx=0; view.ty=0; redraw(); };
  image.src=URL.createObjectURL(f);
});

document.getElementById('csvInput').addEventListener('change', async e=>{
  const f=e.target.files[0]; if(!f) return;
  const txt=await f.text(); const lines=txt.split(/\r?\n/).filter(Boolean); if(lines.length<2) return;
  const h=lines[0].split(',').map(s=>s.trim()); const xi=h.indexOf('Gaze Point X[px]'), yi=h.indexOf('Gaze Point Y[px]');
  if(xi<0||yi<0){csvStatus.textContent='CSV 缺少列：Gaze Point X[px] / Gaze Point Y[px]'; return;}
  gazePoints=[]; for(let i=1;i<lines.length;i++){ const c=lines[i].split(','); const x=Number((c[xi]||'').trim()), y=Number((c[yi]||'').trim()); if(Number.isFinite(x)&&Number.isFinite(y)) gazePoints.push([x,y]); }
  csvStatus.textContent=`已加载 gaze 点：${gazePoints.length}`; redraw();
});

canvas.addEventListener('wheel', e=>{
  if(!imageLoaded) return;
  e.preventDefault();
  const [sx,sy]=canvasPos(e); const [wx,wy]=screenToWorld(sx,sy);
  const factor = e.deltaY<0 ? 1.1 : 0.9;
  view.scale=Math.max(0.2, Math.min(8, view.scale*factor));
  const [nsx,nsy]=worldToScreen(wx,wy);
  view.tx += sx-nsx; view.ty += sy-nsy;
  redraw();
},{passive:false});

canvas.addEventListener('mousedown', e=>{
  if(!imageLoaded) return;
  const [sx,sy]=canvasPos(e); const [wx,wy]=screenToWorld(sx,sy);

  // pan on middle button or alt+drag
  if(e.button===1 || e.altKey){ panMode=true; panStart={x:sx,y:sy}; return; }

  const nv=nearestVertex(wx,wy,10);
  if(nv){ dragVertex=nv; selected={className:nv.className, polyIndex:nv.polyIndex}; redraw(); return; }

  if(drawing){
    if(currentPoly.length>=3){
      const first=currentPoly[0];
      if(Math.hypot(first[0]-wx, first[1]-wy) <= 10/view.scale){
        if(!aois[currentClass]) aois[currentClass]=[];
        aois[currentClass].push({points: currentPoly.slice()});
        currentPoly=[]; redraw(); refreshSummary(); return;
      }
    }
    currentPoly.push([wx,wy]); redraw(); return;
  }

  const sel=selectPolygonAt(wx,wy);
  selected=sel;
  if(sel && e.shiftKey){ dragPoly={...sel,lastX:wx,lastY:wy}; }
  redraw();
});

canvas.addEventListener('mousemove', e=>{
  if(!imageLoaded) return;
  const [sx,sy]=canvasPos(e); const [wx,wy]=screenToWorld(sx,sy);
  hoverCanvasPoint = drawing ? [wx,wy] : null;

  if(panMode && panStart){ view.tx += sx-panStart.x; view.ty += sy-panStart.y; panStart={x:sx,y:sy}; redraw(); return; }

  if(dragVertex){
    aois[dragVertex.className][dragVertex.polyIndex].points[dragVertex.vertexIndex]=[wx,wy];
    redraw(); return;
  }

  if(dragPoly){
    const poly=aois[dragPoly.className][dragPoly.polyIndex].points;
    const dx=wx-dragPoly.lastX, dy=wy-dragPoly.lastY;
    for(let i=0;i<poly.length;i++) poly[i]=[poly[i][0]+dx, poly[i][1]+dy];
    dragPoly.lastX=wx; dragPoly.lastY=wy; redraw(); return;
  }

  if(drawing) redraw();
});

window.addEventListener('mouseup', ()=>{ dragVertex=null; dragPoly=null; panMode=false; panStart=null; });

document.getElementById('startPolyBtn').addEventListener('click', ()=>{ const c=document.getElementById('className').value.trim(); if(!c) return alert('先填类名'); currentClass=c; drawing=true; currentPoly=[]; });
document.getElementById('closePolyBtn').addEventListener('click', ()=>{ if(!drawing||currentPoly.length<3) return alert('至少3点'); if(!aois[currentClass]) aois[currentClass]=[]; aois[currentClass].push({points: currentPoly.slice()}); currentPoly=[]; redraw(); refreshSummary(); });
document.getElementById('undoPointBtn').addEventListener('click', ()=>{ currentPoly.pop(); redraw(); });
document.getElementById('clearCurrentBtn').addEventListener('click', ()=>{ currentPoly=[]; redraw(); });

document.getElementById('deleteSelectedBtn').addEventListener('click', ()=>{
  if(!selected) return alert('先选中一个 polygon');
  aois[selected.className].splice(selected.polyIndex,1);
  if(!aois[selected.className].length) delete aois[selected.className];
  selected=null; redraw(); refreshSummary();
});

document.getElementById('insertVertexBtn').addEventListener('click', ()=>{
  if(!selected) return alert('先选中 polygon');
  if(!hoverCanvasPoint) return alert('把鼠标移到目标边附近');
  const poly=aois[selected.className][selected.polyIndex].points;
  const ne=nearestEdge(poly, hoverCanvasPoint[0], hoverCanvasPoint[1]);
  poly.splice(ne.edgeStart+1,0,[ne.x,ne.y]);
  redraw();
});

document.getElementById('deleteVertexBtn').addEventListener('click', ()=>{
  if(!selected) return alert('先选中 polygon');
  if(!hoverCanvasPoint) return alert('把鼠标移到要删的顶点附近');
  const poly=aois[selected.className][selected.polyIndex].points;
  if(poly.length<=3) return alert('polygon 至少保留3个点');
  let bi=-1, bd=1e9;
  for(let i=0;i<poly.length;i++){
    const d=Math.hypot(poly[i][0]-hoverCanvasPoint[0], poly[i][1]-hoverCanvasPoint[1]);
    if(d<bd){bd=d; bi=i;}
  }
  if(bd>12/view.scale) return alert('离顶点太远');
  poly.splice(bi,1);
  redraw();
});

document.getElementById('renameBtn').addEventListener('click', ()=>{
  const oldN=document.getElementById('renameOld').value.trim(), newN=document.getElementById('renameNew').value.trim();
  if(!oldN||!newN) return alert('填写旧/新类名');
  if(!aois[oldN]) return alert('旧类不存在');
  if(!aois[newN]) aois[newN]=[];
  aois[newN]=aois[newN].concat(aois[oldN]);
  delete aois[oldN]; refreshSummary(); redraw();
});

document.getElementById('aoiImport').addEventListener('change', async e=>{
  const f=e.target.files[0]; if(!f) return;
  const d=JSON.parse(await f.text());
  aois=d.aoi_classes||{};
  for(const k of Object.keys(aois)) aois[k]=(aois[k]||[]).map(p=>({points:(p.points||p)}));
  refreshSummary(); redraw();
});

document.getElementById('exportBtn').addEventListener('click', ()=>{
  if(!imageLoaded) return alert('先上传图片');
  const payload={image:{width:image.width,height:image.height}, aoi_classes:aois};
  const blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='aoi.json'; a.click();
});

document.getElementById('toggleGazeBtn').addEventListener('click', ()=>{ showGaze=!showGaze; redraw(); });

document.getElementById('batchCsvInput').addEventListener('change', e=>{
  batchCsvFiles = Array.from(e.target.files||[]);
  batchStatus.textContent = batchCsvFiles.length ? `已选择 ${batchCsvFiles.length} 个 CSV 文件` : '';
  batchZipBlob = null;
});

document.getElementById('runBatchBtn').addEventListener('click', runBatch);

document.getElementById('downloadBatchZipBtn').addEventListener('click', ()=>{
  if(!batchZipBlob) return alert('请先运行批处理');
  const a=document.createElement('a');
  a.href=URL.createObjectURL(batchZipBlob);
  a.download='batch_results.zip';
  a.click();
});

refreshSummary();
</script>
</body>
</html>
